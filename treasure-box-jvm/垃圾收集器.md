# 垃圾收集器

## 判断对象是否存活

- 引用计数算法
    - 主流Java虚拟机均未采用
    - 很难解决对象循环引用的问题
- 可达性分析算法
    - 通过GC Roots作为树的根节点，根据引用关系向下搜索，走过的路径叫引用链，若对象到GC Roots没有引用链相连时，证明此对象不再使用
    - GC Roots包括：
        - 栈中引用的对象（各线程被调用方法中的参数，局部变量，临时变量）
        - 方法区中类静态属性引用的对象
        - 方法区中常量引用的对象
        - 虚拟机内部的引用（基本数据类型对应的Class对象，常驻的异常对象，系统类加载器）
        - 被同步锁（synchronized）持有的对象
        - 反映虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存
- 引用分类
    - 强引用
        - 普遍存在的引用，如Object obj=new Object()。只要强引用关系还在，则不会被回收
    - 软引用
        - 描述一些还有用，但非必须的对象。在系统即将内存溢出前，会被回收
        - SoftReference
    - 弱引用
        - 比软引用更弱，只能生存到下一次垃圾收集发生
        - WeakReference
    - 虚引用
        - 最弱，无法通过虚引用获取实例。唯一目的是为了能被垃圾收集时收到通知
        - PhantomReference
- 回收方法区
    - 方法区也存在垃圾收集，但需要同时满足多个条件
        - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
        - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
        - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾收集算法
- 分代收集
    - 分代假说
        - 绝大多数对象都是朝生夕灭
        - 熬过越多次垃圾收集过程的对象就越难消亡
        - 跨代引用相对于同代引用来说仅占极少数
    - 分代
        - 新生代（Young Generation）
            - Minor GC / Young GC
        - 老年代（Old Generation）
            - Major GC / Old GC
    - GC
        - 新生代收集（Minor GC / Young GC）：目标只是新生代的垃圾收集
        - 老年代收集（Major GC / Old GC）：目标只是老年代的垃圾收集（CMS收集器才有）
        - 混合收集（Mixed GC）：收集整个新生代和部分老年代（G1收集器）
        - 整堆收集（Full GC）：收集整个堆和方法区
- 算法
    - 标记-清除算法
        - 最基础的手机算法
        - 执行效率随对象数量增长而降低
        - 导致空间碎片化问题
        - CMS关注延迟，基于标记-清除算法，碎片太多时，才会标记-整理收集一次
    - 标记-复制算法
        - 解决标记-清除算法执行效率低的问题
        - 将可用内存等分成两块，只使用其中一块，当本块满了之后，将存活对象复制到另一半，清空本块、
        - 产生大量复制开销，空间使用率低
        - 适合新生代收集（只有少量对象存活，复制的也是少量对象）
        - HotSpot虚拟机
            - Serial、ParNew等新生代收集器把新生代分为一块较大的Eden空间和两块Survivor（8：1）即只浪费10%的空间
            - 若超过Survivor空间，则依赖其他区域来担保（大多是老年代）
    - 标记-整理算法
        - 针对老年代
        - 先标记，后移动
        - 大量的存活对象移动，导致程序暂停
        - Parallel Scavenge 关注吞吐量，基于标记-整理算法
- 经典垃圾收集器
    - ![经典垃圾收集器](img/垃圾收集器.png)
    - 新生代收集器
        - Serial收集器
            - 标记-复制
            - 最基础，最悠久
            - 单线程工作
            - 客户端模式默认
            - 内存消耗小
        - ParNew收集器
            - 标记-复制
            - Serial收集器多线程版本
            - JDK7之前服务端模式首选的新生代收集器
            - 能与CMS收集器配合工作，是激活CMS收集器后默认的新生代收集器
            - 单核环境中效率比Serial差
        - Parallel Scavenge收集器
            - 标记-整理算法
            - 目标是达到可控的吞吐量
            - 不可搭配CMS
    - 老年代收集器
        - Serial Old收集器
            - 标记-整理算法
            - 客户端模式使用
            - 搭配Parallel Scavenge收集器收集老年代
            - CMS收集器失败时的后背预案
        - Parallel Old收集器
            - 标记-整理算法
            - Parallel Scavenge收集器老年代版本
            - 搭配Parallel Scavenge，适合关注吞吐量和处理器资源稀缺的场合
        - CMS收集器（Concurrent Mark Sweep）
            - 关注延迟和响应速度
            - 适合B/S系统的服务端
            - 步骤
                - 初始标记：暂停用户线程，标记GC Roots能直接关联到的对象，速度很快
                - 并发标记：从GC Roots直接关联对象开始遍历整个对象图，耗时长，不暂停，与垃圾收集线程并发运行
                - 重新标记：暂停用户线程，修正并发标记期间用户线程继续运作导致标记产生变动的一部分对象的标记记录，比初始标记阶段稍长
                - 并发清除：清理已经死亡的对象，与用户线程并发
            - 优点
                - 并发收集
                - 低停顿
            - 缺点
                - 对处理器资源敏感，默认回收线程数 （核心数+3）/4，核心数越低
                - 无法处理浮动垃圾，出现Concurrent Mode Failure进而导致Full GC
                    - 浮动垃圾指在并发标记和并发清除阶段产生的垃圾，只能在下一次收集时被处理
                    - Concurrent Mode Failure：并发收集需要预留一部分内存给用户线程，若此时预留的空间被填满，则会出现并发失败，启动后背预案，冻结用户线程，临时用Serial Old收集器收集老年代
                - 收集结束产生大量碎片空间，最终导致Full GC
    - 全功能收集器
        - G1收集器（GarbageFirst）
            - 面向堆内存任何部分来组成回收集（Collection Set / CSet），把堆分成多个大小相等的独立区域（Region），每个Region根据需要扮演Eden，Survivor或者老年代空间
            - 超过Region一半容量的对象为大对象，存放在Region中的Humongous区域，超过整个Region容量的超大对象，则会存放在n个连续的Humongous Region中，被当做老年代处理
            - 有计划地评估各个Region的垃圾堆价值，优先处理价值最大的Region
            - 跨Region引用靠每个Region的记忆集解决，G1至少耗费大约堆的10%-20%的额外内存来维持收集器工作
            - 并发收集阶段新增对象，采用原始快照（SATB）算法实现，每个Region有两个TAMS（Top at Mark Start）指针，Region中一部分空间划分出来用于并发收集过程新对象的分配，若内存回收速度赶不上内存分配的速度，则会冻结用户线程，导致Full GC
            - 步骤
                - 初始标记：类似CMS，但是是借用Minor GC的时候同步完成，G1收集器无额外停顿
                - 并发标记
                - 最终标记
                - 筛选回收：暂停用户线程，更新Region的统计数据，根据回收价值排序Region，并根据用户期望的停顿时间制定回收计划，选择出多个Region构成回收集，再通过复制存活对象到空Region来收集
            - 优点
                - 不产生内存空间碎片
            - 缺点
                - 内存占用和负载比CMS高
- 低延迟垃圾收集器
    - Shenandoah收集器
    - ZGC收集器
